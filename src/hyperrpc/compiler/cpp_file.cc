/* Copyright (c) 2016, Bin Wei <bin@vip.qq.com>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * The name of of its contributors may not be used to endorse or 
 * promote products derived from this software without specific prior 
 * written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <map>
#include <memory>
#include <vector>
#include <google/protobuf/compiler/cpp/cpp_enum.h>
#include <google/protobuf/compiler/cpp/cpp_service.h>
#include <google/protobuf/compiler/cpp/cpp_extension.h>
#include <google/protobuf/compiler/cpp/cpp_helpers.h>
#include <google/protobuf/compiler/cpp/cpp_message.h>
#include <google/protobuf/compiler/cpp/cpp_field.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/stubs/strutil.h>
#include "hyperrpc/compiler/cpp_file.h"
#include "hyperrpc/compiler/cpp_service.h"

namespace hrpc {
namespace compiler {

using namespace ::google::protobuf::compiler::cpp;

CppFileGenerator::CppFileGenerator(const FileDescriptor* file)
    : file_(file)
    , service_generators_(file->service_count())
{
  for (int i = 0; i < file->service_count(); i++) {
    service_generators_[i].reset(new CppServiceGenerator(file->service(i)));
  }
  SplitStringUsing(file_->package(), ".", &package_parts_);
}

CppFileGenerator::~CppFileGenerator()
{
}

void CppFileGenerator::GenerateHeader(io::Printer* printer)
{
  string filename_identifier = FilenameIdentifier(file_->name());
  GenerateTopHeaderGuard(printer, filename_identifier);
  GenerateLibraryIncludes(printer);
  GenerateForwardDeclarations(printer);
  GenerateNamespaceOpeners(printer);
  GenerateServiceDefinitions(printer);
  GenerateNamespaceClosers(printer);
  GenerateBottomHeaderGuard(printer, filename_identifier);
}

void CppFileGenerator::GenerateSource(io::Printer* printer)
{
  string header = StripProto(file_->name()) + ".hrpc.pb.h";
  printer->Print(
    "// Generated by the protobuf compiler hyper-rpc plugin.  DO NOT EDIT!\n"
    "// source: $filename$\n"
    "\n"
    "#include \"$header$\"\n",
    "filename", file_->name(),
    "header", header);

  printer->Print(
    "#include <google/protobuf/descriptor.h>\n"
    "#include <hyperrpc/hyperrpc.h>\n");

  GenerateNamespaceOpeners(printer);

  printer->Print("\nnamespace {\n\n");
  for (int i = 0; i < file_->service_count(); i++) {
    printer->Print(
      "const ::google::protobuf::ServiceDescriptor* $name$_descriptor_ = NULL;\n",
      "name", file_->service(i)->name());
  }

  printer->Print("\n}  // namespace\n\n");

  GenerateBuildDescriptors(printer);

  // Generate services.
  for (int i = 0; i < file_->service_count(); i++) {
    if (i == 0) printer->Print("\n");
    printer->Print(kThickSeparator);
    printer->Print("\n");
    service_generators_[i]->GenerateImplementation(printer);
  }

  GenerateNamespaceClosers(printer);
}

void CppFileGenerator::GenerateNamespaceOpeners(io::Printer* printer)
{
  if (package_parts_.size() > 0) printer->Print("\n");

  for (size_t i = 0; i < package_parts_.size(); i++) {
    printer->Print("namespace $part$ {\n",
                   "part", package_parts_[i]);
  }
}

void CppFileGenerator::GenerateNamespaceClosers(io::Printer* printer) {
  if (package_parts_.size() > 0) printer->Print("\n");

  for (int i = static_cast<int>(package_parts_.size()) - 1; i >= 0; i--) {
    printer->Print("}  // namespace $part$\n",
                   "part", package_parts_[i]);
  }
}

void CppFileGenerator::GenerateTopHeaderGuard(io::Printer* printer,
                                     const std::string& filename_identifier)
{
  printer->Print(
    "// Generated by the protobuf compiler hyper-rpc plugin.  DO NOT EDIT!\n"
    "// source: $filename$\n"
    "\n"
    "#ifndef HRPC_$filename_identifier$__INCLUDED\n"
    "#define HRPC_$filename_identifier$__INCLUDED\n"
    "\n"
    "#include <string>\n",
    "filename", file_->name(), "filename_identifier", filename_identifier);
  printer->Print("\n");
}

void CppFileGenerator::GenerateBottomHeaderGuard(io::Printer* printer,
                                        const string& filename_identifier)
{
  printer->Print(
    "\n"
    "#endif  // HRPC_$filename_identifier$__INCLUDED\n",
    "filename_identifier", filename_identifier);
}

void CppFileGenerator::GenerateLibraryIncludes(io::Printer* printer)
{
  printer->Print("#include <hyperrpc/service.h>\n");
  printer->Print("#include \"$filename$.pb.h\"\n",
                 "filename", StripProto(file_->name()));
}

void CppFileGenerator::GenerateForwardDeclarations(io::Printer* printer)
{
  printer->Print(
    "\n"
    "namespace hrpc {\n"
    "  class HyperRpc;\n"
    "} // namespace hrpc\n");
}

static std::string GetAssignDescriptorsName(const std::string& name)
{
  return "hrpc_" + GlobalAssignDescriptorsName(name);
}

void CppFileGenerator::GenerateBuildDescriptors(io::Printer* printer)
{
  printer->Print(
    "\n"
    "void $assigndescriptorsname$() {\n",
    "assigndescriptorsname", GetAssignDescriptorsName(file_->name()));
  printer->Indent();

  // call AddDesc first
  printer->Print(
    "$adddescriptorsname$();\n",
    "adddescriptorsname", GlobalAddDescriptorsName(file_->name()));

  // get file descriptor
  printer->Print(
    "const ::google::protobuf::FileDescriptor* file =\n"
    "  ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(\n"
    "    \"$filename$\");\n"
    "GOOGLE_CHECK(file != NULL);\n",
    "filename", file_->name());

  // initialize service descriptors
  for (int i = 0; i < file_->service_count(); i++) {
    service_generators_[i]->GenerateDescriptorInitializer(printer, i);
  }

  printer->Outdent();
  printer->Print(
    "}\n"
    "\n");

  printer->Print(
    "namespace {\n"
    "\n"
    "GOOGLE_PROTOBUF_DECLARE_ONCE(hrpc_protobuf_AssignDescriptors_once_);\n"
    "inline void hrpc_protobuf_AssignDescriptorsOnce() {\n"
    "  ::google::protobuf::GoogleOnceInit(\n"
    "                 &hrpc_protobuf_AssignDescriptors_once_,\n"
    "                 &$assigndescriptorsname$);\n"
    "}\n"
    "\n"
    "}  // namespace\n",

    "assigndescriptorsname", GetAssignDescriptorsName(file_->name()));

}

void CppFileGenerator::GenerateServiceDefinitions(io::Printer* printer)
{
  for (int i = 0; i < file_->service_count(); i++) {
    if (i > 0) {
      printer->Print("\n");
      printer->Print(kThinSeparator);
      printer->Print("\n");
    }
    service_generators_[i]->GenerateDeclarations(printer);
  }

  printer->Print("\n");
  printer->Print(kThickSeparator);
  printer->Print("\n");
}

}  // namespace compiler
}  // namespace hrpc
